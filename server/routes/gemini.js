
import express from "express";
// Note: Node.js 18+ has native fetch. If using older Node, ensure 'node-fetch' is installed.
// import fetch from "node-fetch"; 

const router = express.Router();

/**
 * POST /api/gemini-proxy
 * Proxies the request to Google's Gemini API using the User's provided API Key.
 * This ensures CORS compliance and acts as a primary request method.
 */
router.post("/gemini-proxy", async (req, res) => {
  const { apiKey, prompt } = req.body;

  // 1. Strict Input Validation
  if (!apiKey || typeof apiKey !== "string") {
    return res.status(400).json({ error: "Missing or invalid 'apiKey' in request body." });
  }
  if (!prompt || typeof prompt !== "string") {
    return res.status(400).json({ error: "Missing or invalid 'prompt' in request body." });
  }

  try {
    // 2. Call Google Gemini API
    // We STRICTLY use the apiKey passed in the body, ignoring any server-side env vars
    // to ensure we are using the user's specific credentials.
    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          contents: [{ parts: [{ text: prompt }] }],
        }),
      }
    );

    const data = await response.json();

    // 3. Handle Upstream API Errors
    if (!response.ok || data.error) {
      const status = response.status !== 200 ? response.status : 400;
      const message = data.error?.message || "Unknown error from Gemini API";
      return res.status(status).json({ error: message });
    }

    // 4. Extract and Return Text
    const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!generatedText) {
      return res.status(500).json({ error: "No content generated by model." });
    }

    return res.json({ output: generatedText });

  } catch (err) {
    // 5. Handle Network/Server Errors
    console.error("Gemini Proxy Error:", err);
    // Returning 500 triggers the frontend fallback logic
    return res.status(500).json({ error: "Internal Proxy Error", details: err.message });
  }
});

export default router;
